generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== USER MODELS ==============

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  password          String
  username          String    @unique
  firstName         String?   @map("first_name")
  lastName          String?   @map("last_name")
  avatar            String?
  bio               String?
  phone             String?
  isVerified        Boolean   @default(false) @map("is_verified")
  isActive          Boolean   @default(true) @map("is_active")
  lastActive        DateTime? @map("last_active")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  profile           UserProfile?
  garments          Garment[]
  sentSwipes        Swipe[]           @relation("SentSwipes")
  receivedSwipes    Swipe[]           @relation("ReceivedSwipes")
  matchesAsUser1    Match[]           @relation("MatchUser1")
  matchesAsUser2    Match[]           @relation("MatchUser2")
  sentMessages      Message[]         @relation("SentMessages")
  notifications     Notification[]
  superLikesGiven   SuperLike[]       @relation("SuperLikeGiver")
  superLikesReceived SuperLike[]      @relation("SuperLikeReceiver")
  eventParticipations EventParticipant[]
  refreshTokens     RefreshToken[]

  // Future: Blockchain reputation
  reputationScore   Float             @default(0) @map("reputation_score")
  walletAddress     String?           @map("wallet_address")

  @@map("users")
}

model UserProfile {
  id              String   @id @default(uuid())
  userId          String   @unique @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Style preferences
  preferredStyles String[] @map("preferred_styles")
  preferredSizes  String[] @map("preferred_sizes")
  preferredBrands String[] @map("preferred_brands")
  preferredColors String[] @map("preferred_colors")

  // Sizes
  topSize         String?  @map("top_size")
  bottomSize      String?  @map("bottom_size")
  shoeSize        String?  @map("shoe_size")

  // Location (for future geolocation)
  latitude        Float?
  longitude       Float?
  city            String?
  country         String?
  maxDistance     Int      @default(50) @map("max_distance") // km

  // AI-generated style profile (future)
  styleVector     Json?    @map("style_vector")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("user_profiles")
}

model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")

  @@map("refresh_tokens")
}

// ============== GARMENT MODELS ==============

model Garment {
  id              String          @id @default(uuid())
  userId          String          @map("user_id")
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  title           String
  description     String?
  category        GarmentCategory
  subcategory     String?
  brand           String?
  size            String
  color           String
  condition       GarmentCondition
  originalPrice   Float?          @map("original_price")
  estimatedValue  Float?          @map("estimated_value")

  // Images
  images          GarmentImage[]

  // Status
  status          GarmentStatus   @default(ACTIVE)
  isPromoted      Boolean         @default(false) @map("is_promoted")

  // AI-generated data (future)
  detectedBrand   String?         @map("detected_brand")
  detectedColor   String?         @map("detected_color")
  detectedCategory String?        @map("detected_category")
  styleVector     Json?           @map("style_vector")
  tags            String[]

  // Statistics
  viewCount       Int             @default(0) @map("view_count")
  likeCount       Int             @default(0) @map("like_count")
  superLikeCount  Int             @default(0) @map("super_like_count")

  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  // Relations
  swipes          Swipe[]
  superLikes      SuperLike[]
  matchGarment1   Match[]         @relation("MatchGarment1")
  matchGarment2   Match[]         @relation("MatchGarment2")

  @@index([userId])
  @@index([category])
  @@index([status])
  @@map("garments")
}

model GarmentImage {
  id          String   @id @default(uuid())
  garmentId   String   @map("garment_id")
  garment     Garment  @relation(fields: [garmentId], references: [id], onDelete: Cascade)
  url         String
  isPrimary   Boolean  @default(false) @map("is_primary")
  order       Int      @default(0)
  createdAt   DateTime @default(now()) @map("created_at")

  @@map("garment_images")
}

enum GarmentCategory {
  TOPS
  BOTTOMS
  DRESSES
  OUTERWEAR
  SHOES
  ACCESSORIES
  BAGS
  JEWELRY
  SPORTSWEAR
  SWIMWEAR
  OTHER
}

enum GarmentCondition {
  NEW_WITH_TAGS
  LIKE_NEW
  GOOD
  FAIR
  WORN
}

enum GarmentStatus {
  ACTIVE
  SWAPPED
  RESERVED
  INACTIVE
  DELETED
}

// ============== SWIPE & MATCH MODELS ==============

model Swipe {
  id          String      @id @default(uuid())

  swiperId    String      @map("swiper_id")
  swiper      User        @relation("SentSwipes", fields: [swiperId], references: [id], onDelete: Cascade)

  swipedId    String      @map("swiped_id")
  swiped      User        @relation("ReceivedSwipes", fields: [swipedId], references: [id], onDelete: Cascade)

  garmentId   String      @map("garment_id")
  garment     Garment     @relation(fields: [garmentId], references: [id], onDelete: Cascade)

  direction   SwipeDirection
  createdAt   DateTime    @default(now()) @map("created_at")

  @@unique([swiperId, garmentId])
  @@index([swiperId])
  @@index([swipedId])
  @@index([garmentId])
  @@map("swipes")
}

enum SwipeDirection {
  LEFT
  RIGHT
}

model SuperLike {
  id          String   @id @default(uuid())

  giverId     String   @map("giver_id")
  giver       User     @relation("SuperLikeGiver", fields: [giverId], references: [id], onDelete: Cascade)

  receiverId  String   @map("receiver_id")
  receiver    User     @relation("SuperLikeReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  garmentId   String   @map("garment_id")
  garment     Garment  @relation(fields: [garmentId], references: [id], onDelete: Cascade)

  message     String?
  createdAt   DateTime @default(now()) @map("created_at")

  @@unique([giverId, garmentId])
  @@map("super_likes")
}

model Match {
  id          String      @id @default(uuid())

  user1Id     String      @map("user1_id")
  user1       User        @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)

  user2Id     String      @map("user2_id")
  user2       User        @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  garment1Id  String      @map("garment1_id")
  garment1    Garment     @relation("MatchGarment1", fields: [garment1Id], references: [id])

  garment2Id  String?     @map("garment2_id")
  garment2    Garment?    @relation("MatchGarment2", fields: [garment2Id], references: [id])

  status      MatchStatus @default(PENDING)

  // Chat
  conversation Conversation?

  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  @@unique([user1Id, user2Id, garment1Id])
  @@index([user1Id])
  @@index([user2Id])
  @@map("matches")
}

enum MatchStatus {
  PENDING
  ACCEPTED
  NEGOTIATING
  COMPLETED
  CANCELLED
  EXPIRED
}

// ============== CHAT MODELS ==============

model Conversation {
  id          String    @id @default(uuid())
  matchId     String    @unique @map("match_id")
  match       Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)

  messages    Message[]

  lastMessageAt DateTime? @map("last_message_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@map("conversations")
}

model Message {
  id              String        @id @default(uuid())
  conversationId  String        @map("conversation_id")
  conversation    Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId        String        @map("sender_id")
  sender          User          @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  content         String
  type            MessageType   @default(TEXT)
  metadata        Json?

  isRead          Boolean       @default(false) @map("is_read")
  readAt          DateTime?     @map("read_at")

  createdAt       DateTime      @default(now()) @map("created_at")

  @@index([conversationId])
  @@index([senderId])
  @@map("messages")
}

enum MessageType {
  TEXT
  IMAGE
  GARMENT_OFFER
  LOCATION
  SYSTEM
}

// ============== NOTIFICATION MODEL ==============

model Notification {
  id          String            @id @default(uuid())
  userId      String            @map("user_id")
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  type        NotificationType
  title       String
  body        String
  data        Json?

  isRead      Boolean           @default(false) @map("is_read")
  readAt      DateTime?         @map("read_at")

  createdAt   DateTime          @default(now()) @map("created_at")

  @@index([userId])
  @@map("notifications")
}

enum NotificationType {
  NEW_MATCH
  NEW_MESSAGE
  SUPER_LIKE
  SWAP_COMPLETED
  EVENT_REMINDER
  SYSTEM
}

// ============== EVENT MODELS ==============

model Event {
  id              String              @id @default(uuid())
  title           String
  description     String
  type            EventType

  startTime       DateTime            @map("start_time")
  endTime         DateTime            @map("end_time")

  // Location (physical events)
  isVirtual       Boolean             @default(false) @map("is_virtual")
  address         String?
  latitude        Float?
  longitude       Float?

  // Virtual event link
  meetingUrl      String?             @map("meeting_url")

  maxParticipants Int?                @map("max_participants")
  imageUrl        String?             @map("image_url")

  status          EventStatus         @default(UPCOMING)

  participants    EventParticipant[]

  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@map("events")
}

model EventParticipant {
  id          String   @id @default(uuid())
  eventId     String   @map("event_id")
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  status      ParticipantStatus @default(REGISTERED)
  joinedAt    DateTime @default(now()) @map("joined_at")

  @@unique([eventId, userId])
  @@map("event_participants")
}

enum EventType {
  SPEED_SWAPPING
  THEMED_SWAP
  LOCAL_MEETUP
  VIRTUAL_SWAP
}

enum EventStatus {
  UPCOMING
  ACTIVE
  COMPLETED
  CANCELLED
}

enum ParticipantStatus {
  REGISTERED
  CONFIRMED
  ATTENDED
  CANCELLED
}
